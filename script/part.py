import numpy as np
from connectionDB import getDb
from ast import literal_eval
import matplotlib.pyplot as plt

def plot2(x1, x3, x2, y2, n,title):
    fig = plt.figure(n)
    fig.suptitle(title, fontsize=20)
    plt.grid(True)
#   plt.scatter(x1[0], y2[0], c='red')

    # plt.axvline(0, c='red', label='button')
    # print(x1)
    # for x in x1 :
    #     print("x : ", x)
    #     plt.axvline(x, c='red')
    for x in x3:
        # print("x : ", x)
        plt.axvline(x, c='green')
        # plt.plot(x1, y1, 'r')
    plt.plot(x2, y2)

    # plt.legend(loc='upper left', borderaxespad=0.)

    plt.xlabel('timestamp (ms)')
    plt.ylabel('acceleration (m⋅s−2)')

dBFilter = {"sensor_delay": "SENSOR_DELAY_FASTEST" } # {"user_name": "leo", "comment" : "long"}

def formatData():
    accelerometer = []
    button = []
    comments = []
    id = []
    gyroscopeRecord = [[], [], [], []]

    dBResults = getDb()

    for dBResult in dBResults.find(dBFilter):
        accelerometerRecord = [[], [], [], []]
        buttonRecord = [[], []]
        accelerometerRecords = literal_eval(dBResult["accelerometerRecords"])
        buttonRecords = literal_eval(dBResult["buttonRecords"])
        id.append(dBResult["id"])
        comments.append(dBResult["comment"])
        for x in range(int(len(buttonRecords) / 2)):
            buttonRecord[0].append(buttonRecords[2*x])
            buttonRecord[1].append(buttonRecords[2 * x + 1])
        # Partition timestamp, x, y and z axis
        for x in range(int(len(accelerometerRecords)/4)):
            accelerometerRecord[0].append(accelerometerRecords[4*x])
            accelerometerRecord[1].append(accelerometerRecords[4*x + 1])
            accelerometerRecord[2].append(accelerometerRecords[4*x + 2])
            accelerometerRecord[3].append(accelerometerRecords[4*x + 3])
        accelerometer.append(accelerometerRecord)
        button.append(buttonRecord)
    n = 3
    # 0, 2, 3 et 8 intéressants
    # 2 : encadrement un peu bizarre
    # 4, 5, 6 et 7 : pas d'acceleromètre...
    # 18 : rapide ;) <3
    return accelerometer[n], button[n], comments[n], id[n]


def find_nearest(array, value):
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return idx


def get_timestamps(array):
    timestamps = []
    for x in array:
        timestamps.append(x[1])
    return timestamps

dBResults, buttonRecord, comment, id = formatData()

def part(N): # n between 0 and 3 for timestamp, x, y and z
    # Get x major pic
    accelerometerGaps = []
    for accelerometerRecordsIndex in range(len(dBResults[N]) - 1):
        accelerometerGap = abs(float(dBResults[N][accelerometerRecordsIndex + 1]) - float(dBResults[N][accelerometerRecordsIndex]))
        accelerometerGaps.append((accelerometerGap, dBResults[0][accelerometerRecordsIndex + 1]))
    firstsX = sorted(accelerometerGaps, reverse=True)[:100]
    return firstsX


def aggregate_firsts(N, title):
    firstsX = sorted(part(N), key=lambda tup: tup[1])
    timestamps = get_timestamps(firstsX)

    toKeep = []
    i = 1
    n = 0
    length = len(timestamps)
    while (i <length):
        timestamp = timestamps[i]
        timestamp_minus_1 = timestamps[i-1]
        n = 1
        sum = timestamp_minus_1
        while (abs(timestamp_minus_1-timestamp) < 200) and (i <length):
            # We count the timestamp mean
            n += 1
            sum += timestamp

            timestamp_minus_1 = timestamp
            timestamp = timestamps[i]
            i += 1

        if (n != 0 and n != 1):
            timestamp_id = find_nearest(timestamps, sum/n)
            toKeep.append(firstsX[timestamp_id])
        else:
            toKeep.append(firstsX[i-1])
            i += 1

    firstsTimestamps = []
    firstsToKeep = []
    for x in toKeep:
        firstsToKeep.append(x[1])
    for x in firstsX:
        firstsTimestamps.append(x[1])

    plot2(buttonRecord[0], firstsTimestamps, dBResults[0], dBResults[N], 2*N, title + " " + str(id))
    # plot2(buttonRecord[0], firstsToKeep, dBResults[0], dBResults[N], 2*N + 1, title + " to keep " + str(id))
    # return sorted(accelerometerGaps, reverse=True)

def partX():
    aggregate_firsts(1,"Record 2, X")

def partY():
    aggregate_firsts(2, "Record 2, Y")

def partZ():
    aggregate_firsts(3, "Record 2, Z")


partX()
partY()
partZ()
plt.show()
# formatData()
