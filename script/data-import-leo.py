import pandas as pd
import credentials
from pymongo import MongoClient
from bson import ObjectId
from connectionDB import getDb
from ast import literal_eval
import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from keras.layers import Dense
from keras.backend import clear_session
client = MongoClient()
client = MongoClient('mongodb://%s:%s@54.152.156.242:27017' % (credentials._username, credentials._password))
db_name = 'firstdb'
db = client[db_name]
save_data_to_csv = False # saves data to a local csv
window_samples = 6
verbose = False
# returns a list of all dataframes/post corresponding to input
def getDataframe(user_name, orientation, surface, column = None):
    posts = db.posts
    out = []
    for post in posts.find():
        if post["user_name"].lower() == user_name.lower() \
            and post["orientation"].lower() == orientation.lower() \
                and post["surface"].lower() == surface.lower():
            if column: out.append(post[column])
            else: out.append(post)
    return out


def formatData(verbose = False):
    accelerometer = []
    button = []
    comments = []
    id = []
    gyroscopeRecord = [[], [], [], []]

    dBResults = getDb(verbose)

    for dBResult in dBResults.find({"user_name":"xperia", "comment":"200 hits"}):
        accelerometerRecord = [[], [], [], []]
        buttonRecord = [[], []]
        accelerometerRecords = literal_eval(dBResult["accelerometerRecords"])
        buttonRecords = literal_eval(dBResult["buttonRecords"])
        id.append(dBResult["id"])
        comments.append(dBResult["comment"])
        for x in range(int(len(buttonRecords) / 2)):
            buttonRecord[0].append(buttonRecords[2*x])
            buttonRecord[1].append(buttonRecords[2 * x + 1])
        # Partition timestamp, x, y and z axis
        for x in range(int(len(accelerometerRecords)/4)):
            accelerometerRecord[0].append(accelerometerRecords[4*x])
            accelerometerRecord[1].append(accelerometerRecords[4*x + 1])
            accelerometerRecord[2].append(accelerometerRecords[4*x + 2])
            accelerometerRecord[3].append(accelerometerRecords[4*x + 3])
        accelerometer.append(accelerometerRecord)
        # real buttons
        being_pressed = False
        cursor = 0
        current_key = -1
        final_button = []
        for k in range(len(accelerometer[0][0])):
            # print(k, accelerometer[0][0][k])
            if being_pressed:
                if buttonRecord[0][cursor]<accelerometer[0][0][k] and cursor < len(buttonRecord[0])-1:
                    cursor +=1
                    being_pressed = False
                    current_key = buttonRecord[1][cursor]
            else:
                if buttonRecord[0][cursor]<accelerometer[0][0][k] and cursor < len(buttonRecord[0]):
                    cursor +=1
                    being_pressed = True
                    current_key = -1
            final_button.append(current_key)
        data = pd.DataFrame({
            "time":accelerometer[0][0],
            "accelerometer_x":accelerometer[0][1],
            "accelerometer_y":accelerometer[0][2],
            "accelerometer_z":accelerometer[0][3],
            "button":final_button
        })
        # fake buttons: data["button"] = pd.Series([(k//20)%2 == 1 for k in range(data.shape[0])])      
        data["time"] = data["time"]-data["time"][0]
        return data
    
data = formatData()

def continuous_to_interpolated(data, window_samples):
    """
    Input: continuous data
    Output: each line is 3 lists (one for each axis) of several window_samples
    """
    interpolated = [[],[],[], []]
    for row in range(data.shape[0]-window_samples):
        interpolated[0].append([data["accelerometer_x"][k+row] for k in range(6)])
    for row in range(data.shape[0]-window_samples):
        interpolated[1].append([data["accelerometer_y"][k+row] for k in range(6)])
    for row in range(data.shape[0]-window_samples):
        interpolated[2].append([data["accelerometer_z"][k+row] for k in range(6)])
    for row in range(data.shape[0]-window_samples):
        interpolated[3].append(sum([data["button"][k+row]==-1 for k in range(6)])>3)
    return pd.DataFrame({
        "interpolated_x":interpolated[0],
        "interpolated_y":interpolated[1],
        "interpolated_z":interpolated[2],
        "button":interpolated[3]})

interpolated = continuous_to_interpolated(data, window_samples)

# fix random seed for reproducibility
seed = 12
np.random.seed(seed)
#keras.backend.clear_session()
clear_session()

X = np.array(np.array(interpolated["interpolated_x"])+np.array(interpolated["interpolated_y"])+np.array(interpolated["interpolated_z"]))
Y = np.array(interpolated["button"])
arr = np.empty((0,18), int)
for k in range(len(X)):
    # X[k]=np.array(X[k])
    arr = np.append(arr, np.array([X[k]]), axis=0)
X_train, X_test, Y_train, Y_test = train_test_split(arr, Y, test_size=0.33)

# create model
model = Sequential()
# model.add(Dense(window_samples * 4, input_dim= window_samples * 3, activation='relu'))
model.add(Dense(window_samples * 4, input_dim= 18, activation='relu'))
model.add(Dense(window_samples * 2, activation='relu'))
model.add(Dense(window_samples, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
verbosity=1

Y_train_int = [0 for k in range(len(Y_train))]
for k in range(len(Y_train)):
    if Y_train[k]:
        Y_train_int[k] = 1
Y_test_int = [0 for k in range(len(Y_test))]
for k in range(len(Y_test)):
    if Y_train[k]:
        Y_test_int[k] = 1
Y_train_int = np.array(Y_train_int)
Y_test_int = np.array(Y_test_int)
if save_data_to_csv: 
    np.savetxt("data/X_train.csv", X_train, delimiter = ",")
    np.savetxt("data/X_test.csv", X_test, delimiter = ",")
    np.savetxt("data/Y_train_int.csv", Y_train_int, delimiter = ",")
    np.savetxt("data/Y_test_int.csv", Y_test_int, delimiter = ",")
    # X_train = np.loadtxt("X_train.csv", delimiter = ",")
    
model.fit(X_train, Y_train_int,
    validation_data=(X_test, Y_test_int),
    nb_epoch=20,
    batch_size=20,
    verbose=verbosity)

model.summary()

# Evaluate the model on the test data using `evaluate`
print('\n# Evaluate on test data')
results = model.evaluate(X_test, Y_test_int, batch_size=128)
print('test loss, test acc:', results)

# Generate predictions (probabilities -- the output of the last layer)
# on new data using `predict`
print('\n# Generate predictions for 3 samples')
predictions = model.predict(X_test[:3])
print('predictions shape:', predictions.shape)

import random
for k in range(len(Y_train)):
    print(k)
    if Y_train[k]==False:
        print(k)
        if random.random()>0.5:
            print(" DELETE ")
            X_train = np.delete(X_train, k,0)
            Y_train = np.delete(Y_train, k,0)

